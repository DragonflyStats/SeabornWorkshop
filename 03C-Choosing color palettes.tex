
%====================================%
\begin{frame}[fragile]
\frametitle{Seaborn Workshop}
\large

Sequential color palettes
The second major class of color palettes is called “sequential”. This kind of color mapping is appropriate when data range from relatively low or unintersting values to relatively high or interesting values. Although there are cases where you will want discrete colors in a sequential palette, it’s more common to use them as a colormap in functions like kdeplot() or corrplot() (along with similar matplotlib functions).
\end{frame}
%====================================%
\begin{frame}[fragile]
	\frametitle{Seaborn Workshop}
	\large
It’s common to see colormaps like jet (or other rainbow palettes) used in this case, becuase the range of hues gives the impression of providing additional information about the data. However, colormaps with large hue shifts tend to introduce discontinuities that don’t exist in the data, and our visual system isn’t able to naturally map the rainbow to quantitative distinctions like “high” or “low”. The result is that these visualizations end up being more like a puzzle, and they obscure patterns in the data rather than revealing them. The jet palette is particularly bad because the brightest colors, yellow and cyan, are used for intermediate data values. This has the effect of emphasizing uninteresting (and arbitrary) values while demphasizing the extremes.
\end{frame}
%====================================%
\begin{frame}[fragile]
	\frametitle{Seaborn Workshop}
	\large
For sequential data, it’s better to use palettes that have at most a relatively subtle shift in hue accompanied by a large shift in brightness and saturation. This approach will naturally draw the eye to the relatively important parts of the data.
\end{frame}
%====================================%
\begin{frame}[fragile]
\frametitle{Seaborn Workshop}
\large

The Color Brewer library has a great set of these palettes. They’re named after the dominant color (or colors) in the palette.

sns.palplot(sns.color_palette("Blues"))
../_images/color_palettes_25_0.png
Like in matplotlib, if you want the lightness ramp to be reversed, you can add a _r suffix to the palette name.

sns.palplot(sns.color_palette("BuGn_r"))
../_images/color_palettes_27_0.png
Seaborn also adds a trick that allows you to create “dark” palettes, which do not have as wide a dynamic range. This can be useful if you want to map lines or points sequentially, as brighter-colored lines might otherwise be hard to distinguish.

sns.palplot(sns.color_palette("GnBu_d"))
../_images/color_palettes_29_0.png
Remember that you may want to use the choose_colorbrewer_palette() function to play with the various options, and you can set the as_cmap argument to True if you want the return value to be a colormap object that you can pass to seaborn or matplotlib functions.
\end{frame}
%====================================%
\begin{frame}[fragile]
	\frametitle{Seaborn Workshop}
	\large
Sequential palettes with cubehelix_palette()
The cubehelix color palette system makes sequential palettes with a linear increase or decrease in brightness and some variation in hue. This means that the information in your colormap will be preserved when converted to black and white (for printing) or when viewed by a colorblind individual.
\end{frame}
%====================================%
\begin{frame}[fragile]
\frametitle{Seaborn Workshop}
\large

Matplotlib has the default cubehelix version built into it:

sns.palplot(sns.color_palette("cubehelix", 8))
../_images/color_palettes_32_0.png
Seaborn adds an interface to the cubehelix system so that you can make a variety of palettes that all have a well-behaved linear brightness ramp.

The default palette returned by the seaborn cubehelix_palette() function is a bit different from the matplotlib default in that it does not rotate as far around the hue wheel or cover as wide a range of intensities. It also reverses the order so that more important values are darker:

sns.palplot(sns.cubehelix_palette(8))
../_images/color_palettes_34_0.png
\end{frame}
%====================================%
\begin{frame}[fragile]
\frametitle{Seaborn Workshop}
\large

Other arguments to cubehelix_palette() control how the palette looks. The two main things you’ll change are the start (a value between 0 and 3) and rot, or number of rotations (an arbitrary value, but probably within -1 and 1),

sns.palplot(sns.cubehelix_palette(8, start=.5, rot=-.75))
../_images/color_palettes_36_0.png
You can also control how dark and light the endpoints are and even reverse the ramp:

sns.palplot(sns.cubehelix_palette(8, start=2, rot=0, dark=0, light=.95, reverse=True))
../_images/color_palettes_38_0.png
By default you just get a list of colors, like any other seaborn palette, but you can also return the palette as a colormap object that can be passed to seaborn or matplotlib functions using as_cmap=True.

x, y = np.random.multivariate_normal([0, 0], [[1, -.5], [-.5, 1]], size=300).T
cmap = sns.cubehelix_palette(light=1, as_cmap=True)
sns.kdeplot(x, y, cmap=cmap, shade=True);
../_images/color_palettes_40_0.png
\end{frame}
%====================================%
\begin{frame}[fragile]
\frametitle{Seaborn Workshop}
\large

To help select good palettes or colormaps using this system, you can use the choose_cubehelix_palette() function in a notebook to launch an interactive app that will let you play with the different parameters. Pass as_cmap=True if you want the function to return a colormap (rather than a list) for use in function like hexbin.

Custom sequential palettes with light_palette() and dark_palette()
For a simpler interface to custom sequential palettes, you can use light_palette() or dark_palette(), which are both seeded with a single color and produce a palette that ramps either from light or dark desaturated values to that color. These functions are also accompanied by the choose_light_palette() and choose_dark_palette() functions that launch interactive widgets to create these palettes.

sns.palplot(sns.light_palette("green"))
../_images/color_palettes_43_0.png
sns.palplot(sns.dark_palette("purple"))
../_images/color_palettes_44_0.png
These palettes can also be reversed.

sns.palplot(sns.light_palette("navy", reverse=True))
../_images/color_palettes_46_0.png

\end{frame}
%====================================%
\begin{frame}[fragile]
\frametitle{Seaborn Workshop}
\large

They can also be used to create colormap objects rather than lists of colors.

pal = sns.dark_palette("palegreen", as_cmap=True)
sns.kdeplot(x, y, cmap=pal);
../_images/color_palettes_48_0.png
By default, the input can be any valid matplotlib color. Alternate interpretations are controlled by the input argument. Currently you can provide tuples in hls or husl space along with the default rgb, and you can also seed the palette with any valid xkcd color.

sns.palplot(sns.light_palette((210, 90, 60), input="husl"))
../_images/color_palettes_50_0.png
sns.palplot(sns.dark_palette("muted purple", input="xkcd"))
../_images/color_palettes_51_0.png
Note that the default input space for the interactive palette widgets is husl, which is different from the default for the function itself, but much more useful in this context.
\end{frame}
%====================================%
\begin{frame}[fragile]
\frametitle{Seaborn Workshop}
\large


Diverging color palettes
The third class of color palettes is called “diverging”. These are used for data where both large low and high values are interesting. There is also usually a well-defined midpoint in the data. For instance, if you are plotting changes in temperature from some baseline timepoint, it is best to use a diverging colormap to show areas with relative decreases and areas with relative increases.
\end{frame}
%====================================%
\begin{frame}[fragile]
	\frametitle{Seaborn Workshop}
	\large
	
The rules for choosing good diverging palettes are similar to good sequential palettes, except now you want to have two relatively subtle hue shifts from distinct starting hues that meet in an under-emphasized color at the midpoint. It’s also important that the starting values are of similar brightness and saturation.

It’s also important to emphasize here that using red and green should be avoided, as a substantial population of potential viewers will be unable to distinguish them.

It should not surprise you that the Color Brewer library comes with a set of well-choosen diverging colormaps.
\end{frame}
%====================================%
\begin{frame}[fragile]
\frametitle{Seaborn Workshop}
\large

sns.palplot(sns.color_palette("BrBG", 7))
../_images/color_palettes_54_0.png
sns.palplot(sns.color_palette("RdBu_r", 7))
../_images/color_palettes_55_0.png
\end{frame}
%====================================%
\begin{frame}[fragile]
\frametitle{Seaborn Workshop}
\large


Another good choice that is built into matplotlib is the coolwarm palette. Note that this colormap has less contrast between the middle values and the extremes.

sns.palplot(sns.color_palette("coolwarm", 7))
../_images/color_palettes_57_0.png
Custom diverging palettes with diverging_palette()
\end{frame}
%====================================%
\begin{frame}[fragile]
\frametitle{Seaborn Workshop}
\large


You can also use the seaborn function diverging_palette() to create a custom colormap for diverging data. (Naturally there is also a companion interactive widget, choose_diverging_palette()). This function makes diverging palettes using the husl color system. You pass it two hues (in degreees) and, optionally, the lightness and saturation values for the extremes. Using husl means that the extreme values, and the resulting ramps to the midpoint, will be well-balanced

sns.palplot(sns.diverging_palette(220, 20, n=7))
../_images/color_palettes_59_0.png
sns.palplot(sns.diverging_palette(145, 280, s=85, l=25, n=7))
../_images/color_palettes_60_0.png
\end{frame}
%====================================%
\begin{frame}[fragile]
\frametitle{Seaborn Workshop}
\large


The sep argument controls the width of the separation between the two ramps in the middle region of the palette.

sns.palplot(sns.diverging_palette(10, 220, sep=80, n=7))
../_images/color_palettes_62_0.png
It’s also possible to make a palette with the midpoint is dark rather than light.

sns.palplot(sns.diverging_palette(255, 133, l=60, n=7, center="dark"))
../_images/color_palettes_64_0.png
Changing default palettes with set_palette()

\end{frame}
%====================================%
\begin{frame}[fragile]
\frametitle{Seaborn Workshop}
\large

The color_palette() function has a companion called set_palette(). The relationship between them is similar to the pairs covered in the aesthetics tutorial. set_palette() accepts the same arguments as color_palette(), but it changes the default matplotlib parameters so that the palette is used for all plots.
\end{frame}
%====================================%
\begin{frame}[fragile]
	\frametitle{Seaborn Workshop}
	\large
	
def sinplot(flip=1):
    x = np.linspace(0, 14, 100)
    for i in range(1, 7):
        plt.plot(x, np.sin(x + i * .5) * (7 - i) * flip)
sns.set_palette("husl")
sinplot()
../_images/color_palettes_67_0.png
The color_palette() function can also be used in a with statement to temporarily change the color palette.

with sns.color_palette("PuBuGn_d"):
    sinplot()
../_images/color_palettes_69_0.png
\end{frame}
%====================================%
\end{document}
